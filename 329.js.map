{"version":3,"sources":["webpack:///./client/src/setup.ts","webpack:///./client/src/bindings.ts","webpack:///./client/src/broker.ts"],"names":["rand","min","max","Math","random","length","N","ps","vs","range","forEach","i","pos_theta","PI","pos","scale","vel_theta","vel","x","z","Float32Array","engine","state","module","hot","data","then","State","Engine","event","update","positions","map","Vector3","end","error","free","init","setup","addDisposeHandler","hotState","velocities","scheduler","worldSink","worldStream","nextWorld","w","updateSink","updateStream","nextUpdate","u"],"mappings":"0QAIA,MAAMA,EAAO,CAACC,EAAaC,IAAgBC,KAAKC,UAAYF,EAAMD,GAAOA,EAyBzE,EAvBqB,CAACI,EAAS,EAAAC,KAC7B,IAAIC,EAAe,GACfC,EAAe,GAkBnB,OAjBA,EAAAC,EAAA,GAAM,EAAGJ,GAAQK,QAAQC,IACvB,MAAMC,EAAY,kBAAoB,SAAcZ,EAAK,EAAG,EAAIG,KAAKU,KAC/DC,EAAM,yBACV,cAAkBC,MAAMf,EAAK,IAAK,IAClCY,GAEII,EAAY,kBAAoB,SAAchB,EAAK,GAAK,KACxDiB,EAAM,yBACV,UAAcH,EAAK,UAAcC,MAAMf,EAAK,GAAK,KACjDgB,GAGFT,EAAGI,EAAI,KAAQ,MAASG,EAAII,EAC5BX,EAAGI,EAAI,KAAQ,MAASG,EAAIK,EAC5BX,EAAGG,EAAI,KAAQ,MAASM,EAAIC,EAC5BV,EAAGG,EAAI,KAAQ,MAASM,EAAIE,IAEvB,CAAC,IAAIC,aAAab,GAAK,IAAIa,aAAaZ,K,QCnBjD,IAEIa,EAFAC,EAAwD,QAAnD,EAA6C,QAA7C,EAAmCC,EAAOC,WAAG,eAAEC,YAAI,eAAEH,MAI9D,8BAAoBI,KAAK,EAAGC,MAAOC,MACjC,MACE,CACEC,MAAO,KACLR,EAAOS,SACP,MAAMvB,EAAKc,EAAOU,YAClB,EAAiB,CACfA,WAAW,EAAAtB,EAAA,GAAM,EAAG,EAAAH,GAAG0B,IACrBrB,GAAK,IAAI,EAAAsB,QAAQ1B,EAAGI,EAAI,KAAQ,MAAQ,EAAGJ,EAAGI,EAAI,KAAQ,WAIhEuB,IAAK,OACLC,MAAO,QAET,GAEFd,WAAQe,OACRf,GAASC,aAAK,EAALA,EAAOE,KACZI,EAAOS,KAAKf,EAAMf,GAAIe,EAAMd,IAC5BoB,EAAOS,QAAQC,OAInBf,EAAOC,IAAIe,kBAAkBd,IAC3B,MAAMe,EAAmC,CACvCjC,GAAIc,EAAOU,YACXvB,GAAIa,EAAOoB,aACXjB,KAAK,GAEPC,EAAKH,MAAQkB,I,wBCpCV,MAAME,GAAY,WAEXC,EAAWC,GAAe,OAC3BC,EAAaC,IACxB,KAAc,QAAYJ,GAAYI,EAAGH,KAG7BI,EAAYC,GAAgB,OAC7BC,EAAcC,IACzB,KAAc,QAAYR,GAAYQ,EAAGH","file":"329.js","sourcesContent":["import { DIM_N, DIM_X, DIM_Y, N } from \"./types\"\nimport { Matrix, Vector3 } from \"@babylonjs/core/Maths/math.vector\"\nimport { range } from \"ramda\"\n\nconst rand = (min: number, max: number) => Math.random() * (max - min) + min\n\nexport const swarm = (length = N): [Float32Array, Float32Array] => {\n  let ps: number[] = []\n  let vs: number[] = []\n  range(0, length).forEach(i => {\n    const pos_theta = Matrix.RotationAxis(Vector3.Up(), rand(0, 2 * Math.PI))\n    const pos = Vector3.TransformCoordinates(\n      Vector3.Forward().scale(rand(2.5, 4)),\n      pos_theta\n    )\n    const vel_theta = Matrix.RotationAxis(Vector3.Up(), rand(0.1, 0.2))\n    const vel = Vector3.TransformCoordinates(\n      Vector3.Cross(pos, Vector3.Up()).scale(rand(0.3, 0.6)),\n      vel_theta\n    )\n\n    ps[i * DIM_N + DIM_X] = pos.x\n    ps[i * DIM_N + DIM_Y] = pos.z\n    vs[i * DIM_N + DIM_X] = vel.x\n    vs[i * DIM_N + DIM_Y] = vel.z\n  })\n  return [new Float32Array(ps), new Float32Array(vs)]\n}\n\nexport default swarm\n","import * as broker from \"./broker\"\nimport { DIM_N, DIM_X, DIM_Y, N, Nullable } from \"./types\"\nimport { Vector3 } from \"@babylonjs/core\"\nimport { range } from \"ramda\"\nimport setup from \"./setup\"\n\ntype Data = Record<\"ps\" | \"vs\", Float32Array>\nlet state: Nullable<{ hot: true } & Data> = module.hot?.data?.state\n\nlet engine: import(\"../../pkg\").State\n\nimport(\"../../pkg\").then(({ State: Engine }) => {\n  broker.updateStream.run(\n    {\n      event: () => {\n        engine.update()\n        const ps = engine.positions()\n        broker.nextWorld({\n          positions: range(0, N).map(\n            i => new Vector3(ps[i * DIM_N + DIM_X], 0, ps[i * DIM_N + DIM_Y])\n          ),\n        })\n      },\n      end: () => {},\n      error: () => {},\n    },\n    broker.scheduler\n  )\n  engine?.free()\n  engine = state?.hot\n    ? Engine.init(state.ps, state.vs)\n    : Engine.init(...setup())\n})\n\nif (module.hot) {\n  module.hot.addDisposeHandler(data => {\n    const hotState: Required<typeof state> = {\n      ps: engine.positions(),\n      vs: engine.velocities(),\n      hot: true,\n    }\n    data.state = hotState\n  })\n}\n","import \"./bindings\"\nimport * as subject from \"most-subject\"\nimport { Update, World } from \"./types\"\nimport { currentTime, newDefaultScheduler } from \"@most/scheduler\"\n\nexport const scheduler = newDefaultScheduler()\n\nexport const [worldSink, worldStream] = subject.create<World>()\nexport const nextWorld = (w: World) => {\n  subject.event(currentTime(scheduler), w, worldSink)\n}\n\nexport const [updateSink, updateStream] = subject.create<Update>()\nexport const nextUpdate = (u: Update) => {\n  subject.event(currentTime(scheduler), u, updateSink)\n}\n"],"sourceRoot":""}